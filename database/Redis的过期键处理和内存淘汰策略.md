# 缓存过期删除和缓存淘汰
## 过期删除策略（重点）
### Redis是如何判断key过期了？
![](https://pic.imgdb.cn/item/668bdf68d9c307b7e912cec3.png)
- redisDb为存储键值和过期时间的数据结构，如上图所示。expire指向的字典存储过期时间。
- 根据上图容易知道，redis每次能通过O(1)的时间访问expire hash数据结构，通过比对当前时间和l过期时间，就能判断当前键值有没有过期。对咯，他们都是long long类型的。

## 过期删除策略有哪些
### 定时删除策略
- 在设置key过期时间的时候创建一个定时任务，每当key到达过期时间就执行删除key操作。
- 优点：能够及时的删除掉过期的key，节约内存空间。
- 缺点：会使用过多的CPU性能用在删除key上，影响系统处理命令的吞吐量。
### 惰性删除策略
- 每当访问key时我再去检查，过期我就删除。
- 优点：因为只在访问key的时候才检查删除，节约CPU资源。
- 缺点：大量过期的key若一直不访问，就会一直停留在内存中，浪费内存资源。
### 定期删除策略
- 对前两种方案的折中，不马上删除，也不等到访问时才删除，而是设定一个时长定期检查过期的key并删除。
- 优点：既不会浪费大量的CPU资源，又不会浪费过多的内存。
- 缺点：
  - 这个优点不太明显，既没有像惰性策略那样大量节省CPU资源，也没有像定时删除策略那样大量节约内存。
  - 定期的时长不太好把握，太短就接近定期删除策略，太长就接近惰性删除策略。
### Redis采用的哪种过期策略？
- 以上策略都有自己的优缺点，所以一种策略不能满足需求，那怎么办呢？Redis就采用融合思路，采用【惰性删除+定期删除】配合使用。在合理使用CPU和避免浪费内存之间取得平衡，我理解根据CPU和内存状态选择。
- Redis如何实现惰性删除？
  - Redis 的惰性删除策略由 db.c 文件中的 expireIfNeeded 函数实现，代码如下：
  ![](https://pic.imgdb.cn/item/668bdffad9c307b7e913a842.png)
  - 若过期，删除key，返回客户端null；若未过期返回数据。
- Redis如何实现定期删除？
  - Redis默认定期删除时间10，可通过 Redis 的配置文件 redis.conf 进行配置，配置键为 hz 它的默认值是 hz 10，意思是每秒进行十次检查。
  - Redis采用随机删除策略：
![](https://pic.imgdb.cn/item/668be076d9c307b7e9144cf7.png)
- 源码中的定期删除的实现在 expire.c 文件下的 activeExpireCycle 函数中，其中随机抽查的数量由 ACTIVE_EXPIRE_CYCLE_LOOKUPS_PER_LOOP 定义的，它是写死在代码中的，数值是 20。
- 默认不会超过 25ms。
## 内存淘汰策略
- 可通过maxmemory调整redis的最大内存。64位机中默认为0，即不限制内存大小；32位机默认值为3G
- Redis 内存淘汰策略共有八种，这八种策略大体分为「不进行数据淘汰」和「进行数据淘汰」两类策略。
  - 不进行数据淘汰的策略，noeviction（Redis3.0之后，默认的内存淘汰策略）。如果内存满了，只有查询和删除可用。
  - 进行数据淘汰的策略。
    - 在设置了过期时间的数据中淘汰
      - volatile-random：随机淘汰设置了过期时间的任意键值；
      - volatile-ttl：优先淘汰更早过期的键值。
      - volatile-lru（Redis3.0 之前，默认的内存淘汰策略）:淘汰所有设置了过期时间的键值中，最久未使用的键值；
      - volatile-lfu（Redis 4.0 后新增的内存淘汰策略）:淘汰所有设置了过期时间的键值中，最少使用的键值；
    - 在全部数据范围淘汰
      - allkeys-random：随机淘汰任意键值;
      - allkeys-lru: 淘汰整个键值中最久未使用的键值；
      - allkeys-lfu（Redis 4.0 后新增的内存淘汰策略）：淘汰整个键值中最少使用的键值。
- 可以使用 config get maxmemory-policy 命令，来查看当前 Redis 的内存淘汰策略。

### LRU 算法和 LFU 算法有什么区别？
- LFU 内存淘汰算法是 Redis 4.0 之后新增内存淘汰策略，那为什么要新增这个算法？那肯定是为了解决 LRU 算法的问题。
- LRU 全称是 Least Recently Used 翻译为最近最少使用，会选择淘汰最近最少使用的数据。
  - 传统 LRU 算法的实现是**基于「链表」结构**，链表中的元素按照操作顺序从前往后排列，最新操作的键会被移动到表头，当需要内存淘汰时，只需要删除链表尾部的元素即可，因为链表尾部的元素就代表最久未被使用的元素。Redis不采用的原因有两点：
    - 如果存在大量数据访问，链表指针会频繁移动，影响redis性能。
    - 需要链表管理所有缓存数据，带来额外空间开销。
  - Redis 实现的是一种**近似 LRU 算法**，目的是**为了更好的节约内存**，它的实现方式是在 Redis 的对象结构体中添加一个额外的字段，用于记录此数据的最后一次访问时间。当 Redis 进行内存淘汰时，会使用随机采样的方式来淘汰数据，它是随机取 5 个值（此值可配置），然后淘汰最久没有使用的那个。
    - 存在问题：没办法解决无法解决缓存污染问题。即大量只访问一次的数据加入缓存。因此，在 Redis 4.0 之后引入了 LFU 算法来解决这个问题。
- LFU 全称是 Least Frequently Used 翻译为**最近最不常用**，LFU 算法是根据数据访问次数来淘汰数据的，它的核心思想是“如果数据过去被访问多次，那么将来被访问的频率也更高”。
  - Redis如何实现LFU？
  ![](https://pic.imgdb.cn/item/668be191d9c307b7e915ed92.png)
  - 这个字段在不同算法中用处不同。
    - 在LRU算法中，lru字段记录时间戳。算法就可以通过这个字段判断哪个数据最长时间没有访问到，从而执行淘汰。
    - 在LFU算法中，Redis对象头的 24 bits 的 lru 字段被分成两段来存储。
![](https://pic.imgdb.cn/item/668be1ccd9c307b7e9164277.png)
      - 高16bit存储ldt(Last Decrement Time)，低8bit存储logc(Logistic Counter)。
      - ldt 是用来记录 key 的访问时间戳；logc 是用来记录 key 的访问频次，它的值越小表示使用频率越低，越容易淘汰，每个新加入的 key 的logc初始值为 5。
      - 注意，logc 并不是单纯的访问次数，而是访问频次（访问频率），因为 logc 会随时间推移而衰减的。在每次 key 被访问时，会先对 logc 做一个衰减操作，衰减的值跟前后访问时间的差距有关系。如果上一次访问的时间与这一次访问的时间差距很大，那么衰减的值就越大，这样实现的 LFU 算法是根据访问频率来淘汰数据的，而不只是访问次数。访问频率需要考虑 key 的访问是多长时间段内发生的。key 的先前访问距离当前时间越长，那么这个 key 的访问频率相应地也就会降低，这样被淘汰的概率也会更大。
      - 对 logc 进行增加操作，增加操作并不是单纯的 + 1，而是根据概率增加，如果 logc 越大的 key，它的 logc 就越难再增加。
# 参考
- [Redis 过期删除策略和内存淘汰策略有什么区别？](https://xiaolincoding.com/redis/module/strategy.html)
- [Redis数据淘汰算法](https://cloud.tencent.com/developer/article/1685760)