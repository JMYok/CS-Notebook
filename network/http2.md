# HTTP/1.1 协议的性能问题
## 背景
- **消息的大小变大了**。从几KB大小的消息，到几MB大小的消息
- **页面资源变多了**。从每个页面不到10个的资源，到每页超100多个资源
- **内容形式变多样了**。从单纯到文本内容，到图片、视频、音频等内容
- **实时性要求变高了**。对页面的实时性要求的应用越来越多
## 问题
- **延迟难以下降**。虽然现在网络的「带宽」相比以前变多了，但是延迟降到一定幅度后，就很难再下降了，说白了就是到达了延迟的下限。
- **并发连接有限**。谷歌浏览器最大并发连接数是 6 个，而且每一个连接都要经过 TCP 和 TLS 握手耗时，以及TCP慢启动过程给流量带来的影响。
- **队头阻塞问题**。同一连接只能在完成一个 HTTP 事务（请求和响应）后，才能处理下一个事务。
- **HTTP 头部巨大且重复**。由于 HTTP 协议是无状态的，每一个请求都得携带 HTTP 头部，特别是对于有携带Cookie的头部，而 Cookie 的大小通常很大。
- **不支持服务器推送消息**。因此当客户端需要获取通知时，只能通过定时器不断地拉取消息，这无疑浪费大量了带宽和服务器资源。

尽管对 HTTP/1.1 协议的优化手段如此之多，但是效果还是不尽人意，因为这些手段都是对 HTTP/1.1 协议的“外部”做优化，而**一些关键的地方是没办法优化的**，比如请求-响应模型、头部巨大且重复、并发连接耗时、服务器不能主动推送等，要改变这些必须重新设计 HTTP 协议，于是 HTTP/2 就出来了！

# 兼容 HTTP/1.1
- HTTP/2 没有在 URI 里引入新的协议名，仍然用「http://」表示明文协议，用「https://」表示加密协议，于是只需要浏览器和服务器在背后自动升级协议，这样可以让用户意识不到协议的升级，很好的实现了协议的平滑升级。
- 只在应用层做了改变，还是基于 TCP 协议传输，应用层方面为了保持功能上的兼容，HTTP/2 把 HTTP 分解成了「语义」和「语法」两个部分，**「语义」层不做改动，与 HTTP/1.1 完全一致，比如请求方法、状态码、头字段等规则保留不变**。但是，HTTP/2 在「语法」层面做了很多改造，基本改变了 HTTP 报文的传输格式。
# 头部压缩
HTTP/2 没使用常见的 gzip 压缩方式来压缩头部，而是开发了 HPACK 算法，HPACK 算法主要包含三个组成部分：
- 静态字典
- 动态字典
- Huffman 编码（压缩算法）；

客户端和服务器两端都会建立和维护「字典」，用长度较小的索引号表示重复的字符串，再用 Huffman 编码压缩数据，可达到 50%~90% 的高压缩率。
### 静态字典
- HTTP/2 为**高频出现在头部的字符串和字段**建立了一张静态表，它是写入到 HTTP/2 框架里的，不会变化的，静态表里共有 61 组。
- Index 表示索引（Key），Header Value 表示索引对应的 Value，Header Name 表示字段的名字，**比如 Index 为 2 代表 GET，Index 为 8 代表状态码 200**。表中有的 Index 没有对应的 Header Value，这是因为这些 Value 并不是固定的而是变化的，这些 Value 都会经过 Huffman 编码后，才会发送出去。
- HTTP/2 头部由于基于二进制编码，就不需要冒号空格和末尾的\r\n作为分隔符，于是改**用表示字符串长度（Value Length）来分割 Index 和 Value**。![](https://pic.imgdb.cn/item/6694b2f5d9c307b7e9f80b0c.png)
- 在统计大量的 HTTP 头部后，HTTP/2 根据出现频率将 ASCII 码编码为了 Huffman 编码表，可以在 RFC7541 文档找到这张静态 Huffman 表。![](https://pic.imgdb.cn/item/6694b277d9c307b7e9f75bf6.png)

![](https://pic.imgdb.cn/item/6694b1f3d9c307b7e9f6aa03.png)

### 动态字典
- 静态表只包含了 61 种高频出现在头部的字符串，不在静态表范围内的头部字符串就要自行构建动态表，它的 Index 从 62 起步，会在编码解码的时候随时更新。
- 比如，第一次发送时头部中的「User-Agent」字段数据有上百个字节，经过 Huffman 编码发送出去后，**客户端和服务器双方都会更新自己的动态表，添加一个新的 Index 号 62**。那么在下一次发送的时候，就不用重复发这个字段的数据了，只用发 1 个字节的 Index 号就好了，因为双方都可以根据自己的动态表获取到字段的数据。所以，**使得动态表生效有一个前提：必须同一个连接上，重复传输完全相同的 HTTP 头部**。如果消息字段在 1 个连接上只发送了 1 次，或者重复传输时，字段总是略有变化，动态表就无法被充分利用了（例如User-Agent的index又会变为63）。
### 全过程
![](https://pic.imgdb.cn/item/6694b450d9c307b7e9f9c6f2.png)

# 二进制帧

# 并发传输

# 服务器主动推送资源


# 参考
- [3.6 HTTP/2 牛逼在哪？](https://xiaolincoding.com/network/2_http/http2.html)