# 体会内存对齐
```go
// 64位系统
#include<stdio.h>

struct{
    int  a;
    char b;
}s;

int main ()
{
    printf ("%d\n",sizeof(s);  
    return 0;
}

```
理论上，64位系统下，int占 4个byte，char占 1个byte，那么将它们放到一个结构体中应该占 4+1 = 5byte；但是实际上，通过运行程序得到的结果是 8byte，这就是内存对齐所导致的。

# 什么是内存对齐
简单来说，就是编译器把程序中的每个“数据单元”放在合适的位置上。

那什么叫做合适的位置？
# 为什么需要内存对齐
计算机的处理器是以一定大小的**块**来进行读取的,一般会以双字节,四字节,8字节,16字节,甚至32字节的内存存取粒度来存取内存。

若不对齐可能会消耗更多的处理器性能。例如，读取未内存对齐的int型变量需要读取两次，还涉及剔除和合并的过程：
![](https://pic.imgdb.cn/item/669907dcd9c307b7e9c2e56f.png)
而内存对齐后，一次读取即可：
![](https://pic.imgdb.cn/item/669907f3d9c307b7e9c2fef6.png)

# 保证内存对齐
## 标准数据类型
它的地址只要是它的长度的整数倍就行了
## 结构体
在结构体中，编译器为结构体的每个成员按其自然边界（alignment）分配空间。各个成员按照它们被声明的顺序在内存中顺序存储，第一个成员的地址作为整个结构体的地址。具体规则如下：
> 1. 第一个成员在结构体变量偏移量为0 的地址处，也就是第一个成员必须从头开始。
> 2. 以后每个成员相对于结构体首地址的 offset 都是该成员大小的整数倍，如有需要编译器会在成员之间加上填充字节。
> 3. 结构体的总大小为 最大对齐数的整数倍（每个成员变量都有自己的对齐数），如有需要编译器会在最末一个成员之后加上填充字节。
> 4. 如果嵌套结构体，嵌套的结构体对齐到自己的最大对齐数的整数倍处，结构体的整体大小就是所有最大对齐数（包含嵌套结构体的对齐数）的整数倍。

结合例子理解：
```go
struct test_t {
  int   a;
  long  b;
  short c;
};
```
![](https://pic.imgdb.cn/item/66990997d9c307b7e9c4c15a.png)
绿色表示编译器填充字节。

如果将short字段提前呢？
```go
struct test_t {
  int   a;
  short b;
  long  c;
};
```
![](https://pic.imgdb.cn/item/66990a9cd9c307b7e9c5f43a.png)
可见，**对于成员相同的结构体，如果改变成员的顺序，对于结构体所占空间的大小是会产生影响的**，所以，我们不但要了解内存对齐，还是正确的利用内存对齐。
# 参考
- https://juejin.cn/post/6870162226032934926